                         
##                # This is a program for downloading the preliminary data from recount3 into the directory
## if (!requireNamespace("BiocManager", quietly = TRUE)) { 
##     install.packages("BiocManager")
## }



## BiocManager::install("LieberInstitute/recount3") # install recount3
## BiocManager::install("recount")
## install.packages(c("tidyverse", "plyr"))
## # Load required libraries
library(recount3) # load the recount3 library
library(recount)
library(tidyverse)
library(plyr)



## createProjects is a function for processing the raw rse files
createProjects <- function(human_projects, studies) {
    projects <- list()
    for(i  in 1:length(studies)){
    print(i)
  # get project info for a specific project
  proj_info <- subset(
    human_projects,
    project == studies[i] #& project_type == "data_sources"
  )
    
    projects[[i]] = create_rse(proj_info)
    }
    return(projects)
}



## createMetadata is a funcito for creating metadat from the sra file
## Takes as an input a list of rse objects generated by createProjects
createMetadata <- function(projects) {
    all_metadata <- list()
    for(i in 1:length(projects)) {
        metadata =  tryCatch({expand_sra_attributes(projects[[i]])},
        error = function(e) {})
    if(is.null(metadata)) {
        print(paste("skipping", i))
        next
    }
        all_metadata[[i]] = colData(metadata)
    }
    return(all_metadata)
}
    


## filterMetadata is a function for filtering the list of metadata tables by keywords of interest
## It takes as inputs the list of metadata tables and a vector of character keywords
filterMetadata <- function(metadata,keywords) {
    keys <- paste(keywords, collapse = "|")
    results <- lapply(metadata, function(x) x[, grep(keys, names(x))])
    return(results)
}




## aggregateData is a function for aggregating the metadata together
## It takes as an input the list producted by filteredMetadata
aggregateData <- function(filtered_metadata) {
    dat <- lapply(filtered_metadata, as.data.frame)
    aggregated_data <- Reduce(function(x,y) rbind.fill(x,y), dat)
    return(aggregated_data)
}

createMetadataNoRSE <- function(projects) {
    metadata <- list()
    for(i in 1:length(projects)) {
        print(i/length(projects))
        metadata[[i]] <- tryCatch({read_metadata(file_retrieve(locate_url(projects[i], type = "metadata"), verbose = F))$sra.sample_attributes}, error = function(e) {})
    }


}



createMetadataNoRSE_save <- function(projects) {

    for(i in 1:length(projects)) {
        print(i/length(projects))
       tryCatch({
            metadata = read_metadata(file_retrieve(locate_url(projects[i], type = "metadata"), verbose = F))$sra.sample_attributes
            write.table(metadata, file = sprintf("./recount_metadata/%s_metadata.txt", projects[i]), row.names = F, col.names = F)

            }, error = function(e) {})
        
    }


}


human_projects <- available_projects(organism = "human") # load all human projects
studies <- human_projects$project
#projects <- createProjects(human_projects, studies)
## It appears that the variable "sra.sample_attributes" has everything that I am looking for, at least in the DS samples.
#keywords<- c("sra.sample_attribute")
#metadata <- createMetadata(projects)
#tissue_info <- filterMetadata(metadata,keywords)
#aggregated_data <- aggregateData(tissue_info)


createMetadataNoRSE_save(studies)


#save(aggregated_data, file = "aggregated_data.RData")
